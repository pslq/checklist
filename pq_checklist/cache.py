from . import debug_post_msg
from collections import deque
from threading import RLock

'''
  This class create the method to handle in-memory cache for objects going and coming from the Database interface
  By using a cache mechanism the network and disk IOs are reduced which results in better performance
'''
class pq_cache:
  __slots__ = ( 'last_pol', 'keys', 'values', 'mx', 'logger', 'rlock', 'qlen' )

  def __init__(self, logger = None, qlen:int = 32) -> None:
    '''
    Class initializer function

    :type logger: pq_logger class
    :param logger: Logging service to send all messages

    :type qlen: int
    :param qlen: Amount of registries that will be stored into the cache
    '''
    self.last_pol:int = 0
    self.qlen:int     = qlen
    self.rlock        = RLock()
    self.logger       = logger
    # Initiate the elements
    self.reset()
    return(None)

  def _encode_key(self, key) -> bytes:
    '''
    Convert the keys to bytes

    :type key: str
    :param key: String to be encoded
    '''
    ret = bytes()
    try :
      ret = key.encode()
    except :
      try :
        ret = key.tobytes()
      except :
        ret = bytes(key)
    return(ret)

  def exp(self) -> list:
    '''
    Export Current cache elements to a dict ( which can be used to populate another cache instance )
    Return a dict with all cache elements
    '''
    ret = []
    with self.rlock :
      ret = [ ( k,v ) for k,v in zip(self.keys, self.values ) ]
    return(ret)

  def imp(self, data:list) -> bool:
    '''
    Import a dict ( created by exp() function )

    :type data: list
    :param data: list of objects to be imported into the cache ( the list must be generated by the exp() function )

    '''
    ret:bool = True
    for i in data :
      try :
        if not self.add(i[0],i[1], call_encode=False) :
          debug_post_msg(self.logger, 'pq_cache.imp : error inserting key %s into cache '%i[0])
          ret = False
          break
      except Exception as e:
        debug_post_msg(self.logger, 'pq_cache.imp : err on data format: %s'%e, raise_type=Exception)
        ret = False
        break
    return(ret)

  def __getitem__(self,key):
    '''
    Return dict like results
    '''
    return(self.search(key))

  def search(self, key) :
    '''
    Get the value of a determined key from the cache, and return None if the key is not found

    :type key: str
    :param key: key to be fetched from the cache
    '''
    ret = None
    to_find = self._encode_key(key)
    try :
      pos = self.keys.index(to_find)
      ret = self.values[pos]
    except :
      pass
    return(ret)

  def add(self, key, value, call_encode:bool = True, overwrite_value:bool = False) -> bool:
    '''
    Add a new element to the cache

    :type key: str
    :param key: Identifier to localize the element later

    :type value: PyObject
    :param value: Data to be stored

    :type call_encode: bool
    :param call_encode: Key must be in bytes format to be stored, anf will be converted automatically to bytes by default, unless this flag is set to False

    :type overwrite_value: bool
    :param overwrite_value: By detail if a determined key is already stored, the new add will be ignored, this cause the already stored value to be overwritten by this new one

    Returns:
      True if add was sucessfull or False in case of Failure
    '''
    ret:bool = True
    if call_encode :
      enc = self._encode_key(key)
    else :
      enc = key

    with self.rlock :
      try :
        pos:int = self.keys.index(enc)
        if overwrite_value :
          self.values[pos] = value
        else :
          ret = False
      except :
        try :
          self.last_pol += 1
          self.keys[self.last_pol]   = enc
          self.values[self.last_pol] = value
        except :
          self.last_pol = 0
          self.keys[self.last_pol]   = enc
          self.values[self.last_pol] = value
    return(ret)


  def get_append_func_from_key(self, key, call_encode:bool = True) :
    '''
    Returns the append function of a determined key if such is available

    :type key: str
    :param key: Key that holds the list ( or the object that expose the append method ) which \'value\' will be appended

    :type call_encode: bool
    :param call_encode: If the key should be translated to bytes before process ( all object keys are in bytes format for compatibility with REDIS )
    '''
    if call_encode :
      enc = self._encode_key(key)
    else :
      enc = key
    ret = None
    with self.rlock :
      try:
        ret = self.values[self.keys.index(enc)].append
      except :
        pass
    return(ret)

  def append_to_key(self, key, value, call_encode:bool = True) -> bool:
    '''
    If the value of a determined key has the append method, this function allow to call this function to store more data

    :type key: str
    :param key: Key that holds the list ( or the object that expose the append method ) which \'value\' will be appended

    :type value: PyObject
    :param value: Object to be appended into the list like object stored at the position defined by key

    :type call_encode: bool
    :param call_encode: If the key should be translated to bytes before process ( all object keys are in bytes format for compatibility with REDIS )
    '''
    ret:bool = False
    try :
      with self.rlock :
        append = self.get_append_func_from_key(key, call_encode = call_encode)
        if append :
          append(value)
          ret = True
    except Exception as e :
      debug_post_msg(self.logger, 'pq_cache.append_to_key : err : %s'%e)
    return(ret)

  def reset(self) -> True:
    '''
    Empty cache contents
    '''
    with self.rlock :
      try:
        self.keys.clear()
        self.values.clear()
      except :
        pass
      self.keys   = deque(range(self.qlen))
      self.values = deque(range(self.qlen))
      self.mx:int = len(self.keys)-1

    return(True)

